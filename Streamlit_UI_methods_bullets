import re
import streamlit as st
import requests
import json
import logging
import streamlit as st
import uuid
import ast
import hashlib

import os
from dotenv import load_dotenv
load_dotenv()


# Set page configuration
st.set_page_config(
    page_title="CRP",
    layout="wide",
    initial_sidebar_state="expanded",
)


# Custom CSS to apply styles
st.markdown("""
    <style>
        /* Apply custom font-family, font-size, and color */
        .st-emotion-cache-wq5ihp {
            font-family: "Source Sans Pro", sans-serif;
            font-size: 1.3rem;
            color: inherit;
        }
    </style>
""", unsafe_allow_html=True)


API_BASE_URL = "http://localhost:5000/"


# Initialize session state variables
def initialize_session_state():
    default_sections = ["introduction", "methods", "discussion", "results", "conclusion"]
    
    # General session states
    for key in ["file_name", "assistant_id", "vector_id", "current_thread_id", "current_checkbox_thread_id", 
                "edited_response", "response", "citations", "checkbox_response", "checkbox_citations", 
                "dependent", "checkbox_dependent", "user_query", "selected_results_bullets", "selected_methods_items",
                "results_checkboxes_state"]:
        if key not in st.session_state:
            if key in ["dependent", "checkbox_dependent"]:
                st.session_state[key] = True
            elif key in ["selected_results_bullets", "selected_methods_items"]:
                st.session_state[key] = []  # Initialize as empty lists
            elif key == "results_checkboxes_state":
                st.session_state[key] = {}  # Dictionary to track checkbox states
            else:
                st.session_state[key] = ""
    
    # Section-specific session states
    for section in default_sections:
        if section not in st.session_state:
            st.session_state[section] = ""
        for sub_key in [
            f"{section}_thread_id",
            f"{section}_citations",
            f"{section}_prompt",
            f"{section}_chat",
            f"{section}_chat_citations",
            f"initialise_new_chat_for{section}_thread_id",  # Add this line

            f"initialise_new_chat_for_outside_{section}_thread_id",
            f"outside_{section}_thread_id",
            f"outside_{section}_citations",
            f"outside_{section}_prompt",
            f"outside_{section}_chat",
            f"outside_{section}_chat_citations",
        ]:
            if sub_key not in st.session_state:
                st.session_state[sub_key] = [] if 'citations' in sub_key else ""
    
    # Initialize additional session state variables for outside queries
    for key in ["selected_queries_outside", "selected_responses_outside", "results_outside", "final_edited_responses_outside", "view_final_edited_outside", "show_results", "show_selected_query", "assistant_response"]:
        if key not in st.session_state:
            if key == "view_final_edited_outside":
                st.session_state[key] = False  # Boolean value for "view_final_edited_outside"
            else:
                st.session_state[key] = []  # Default to empty list for the others


initialize_session_state()



# Function to clear session state when a new file is uploaded
def clear_session():
    # General session states to clear
    for key in ["file_name", "assistant_id", "vector_id", "current_thread_id", "current_checkbox_thread_id", 
                "edited_response", "response", "citations", "checkbox_response", "checkbox_citations", 
                "dependent", "checkbox_dependent", "user_query", "selected_results_bullets", "selected_methods_items"]:
        if key in ["dependent", "checkbox_dependent"]:
            st.session_state[key] = True
        elif key in ["selected_results_bullets", "selected_methods_items"]:
            st.session_state[key] = []  # Reset as empty lists
        else:
            st.session_state[key] = ""
    
    # Section-specific session states to clear
    default_sections = ["introduction", "methods", "discussion", "results", "conclusion"]
    for section in default_sections:
        st.session_state[section] = ""
        for sub_key in [
            f"{section}_thread_id",
            f"{section}_citations",
            f"{section}_prompt",
            f"{section}_chat",
            f"{section}_chat_citations",
            f"initialise_new_chat_for{section}_thread_id",  # Add this line to clear the new session variable

            f"initialise_new_chat_for_outside_{section}_thread_id",
            f"outside_{section}_thread_id",
            f"outside_{section}_citations",
            f"outside_{section}_prompt",
            f"outside_{section}_chat",
            f"outside_{section}_chat_citations",
        ]:
            st.session_state[sub_key] = [] if 'citations' in sub_key else ""
    
    # Clear additional session state variables for outside queries
    for key in ["selected_queries_outside", "selected_responses_outside", "results_outside", "final_edited_responses_outside", "view_final_edited_outside",  "show_results", "show_selected_query", "assistant_response"]:
        if key in st.session_state:
            if key == "view_final_edited_outside":
                st.session_state[key] = False  # Reset to False
            else:
                st.session_state[key] = []  # Clear by setting to an empty list



 

# Title and Instructions
st.title("CLINICAL RESEARCH PAPER")

# File Upload Section
st.header("üìÅ Upload File")
uploaded_file = st.file_uploader("Choose a file to upload", type=["txt", "csv", "json", "pdf"])

col1, col2 = st.columns([3, 1])
with col1:
    pass  # Placeholder for alignment
with col2:
    if st.button("Upload File"):
        if uploaded_file is not None:
            try:
                # Clear session state before uploading a new file
                clear_session()

                files = {"file": uploaded_file}
                response = requests.post(f"{API_BASE_URL}/upload", files=files)
                if response.status_code == 200:
                    result = response.json()
                    if isinstance(result, dict):
                        st.success(result.get("message", "File uploaded successfully!"))
                        # Pre-fill session metadata fields from the response
                        st.session_state.file_name = uploaded_file.name
                        st.session_state.assistant_id = result.get("assistant_id", "")
                        st.session_state.vector_id = result.get("vector_store_id", "")
                        st.session_state.current_thread_id = result.get("thread_id", "")  # Adjust based on your response
                    else:
                        # Handle other response structures if necessary
                        st.success("File processed successfully!")
                else:
                    st.error(response.json().get("error", "Failed to upload file."))
            except Exception as e:
                st.error(f"Error: {str(e)}")
        else:
            st.error("Please select a file to upload.")

# Metadata Input Section
st.header("üìù Session Metadata")
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.text_input("**File Name**", st.session_state.file_name, key="meta_file_name")
with col2:
    st.text_input("**Assistant ID**", st.session_state.assistant_id, key="meta_assistant_id")
with col3:
    st.text_input("**Vector ID**", st.session_state.vector_id, key="meta_vector_id")
with col4:
    st.text_input("**Current Thread ID**", st.session_state.current_thread_id or "", key="meta_thread_id")

# User Input: Query Section
st.header("‚ùì  Initiate a New General Query")
user_query = st.text_area("Enter your query", "", height=100)


dependent = st.checkbox("Dependent on thread", value=True)
st.session_state["dependent"] = dependent

get_dependent_status = lambda: "ON" if st.session_state['dependent'] else "OFF"

# Display the conversation status
st.write(f"Conversation: {get_dependent_status()}")


# st.write(f"Conversation: {st.session_state['dependent']}")
if st.button("Ask Assistant"):
    if user_query:
        try:
            # Clear previous response and citations from the session state
            st.session_state["response"] = ""
            st.session_state["citations"] = []

            # Send metadata and the user query to the backend
            payload = {
                "question": user_query,
                "file_name": st.session_state.file_name,
                "assistant_id": st.session_state.assistant_id,
                "vector_id": st.session_state.vector_id,
                "current_thread_id": st.session_state.current_thread_id or None,
                "dependent": st.session_state["dependent"], 
            }
            response = requests.post(f"{API_BASE_URL}/query", json=payload)
            if response.status_code == 200:
                result = response.json()
                assistant_response = result.get("response", "")
                citations = result.get("citations", [])
                thread_id = result.get("thread_id", None)

                st.session_state.current_thread_id = thread_id  # Update current thread ID
                st.session_state["response"] = assistant_response
                st.session_state["citations"] = citations

                st.success("Assistant responded to your query!")
            else:
                st.error(response.json().get("error", "Please upload the file to start your query"))
        except Exception as e:
            st.error(f"Error: {str(e)}")
    else:
        st.error("Please enter a query before asking.")

# Display editable text area for the query response
if "response" in st.session_state and st.session_state["response"]:
    st.header("üí¨ Response")
    response_text = st.text_area("Response:", st.session_state["response"], height=200, key="response_text")
    citations = st.session_state["citations"]

    # st.markdown("**Citations:**")
    # for citation in citations:
    #     st.write(f"- {citation}")

    if st.session_state.current_thread_id:
        st.markdown(f"**Thread ID:** {st.session_state.current_thread_id}")

    # Save Response Button
    if st.button("Save Response"):
        payload = {
            'file_name': st.session_state.file_name,
            'user_query': user_query,
            'assistant_response': response_text,
            'citations': citations,
            'thread_id': st.session_state.current_thread_id
        }
        try:
            save_response = requests.post(f"{API_BASE_URL}/save_response", json=payload)
            if save_response.status_code == 200:
                st.success("Response saved successfully!")
            else:
                st.error("Error saving response.")
        except Exception as e:
            st.error(f"An error occurred: {e}")










# Function to generate a unique key for each checkbox
def generate_unique_key(*args):
    # Use a hash of the arguments to create a unique key
    return hashlib.md5("".join(map(str, args)).encode('utf-8')).hexdigest()

# Function to display endpoints without recursion
def display_endpoints(name, item, section_name="results"):
    selected_bullet = None  # To store the selected bullet point
    selected_category = None  # To store the selected category
    show_button = False  # To track if we should show the button

    stack = [(name, item)]  # Initialize stack with the root level
    while stack:
        current_name, current_item = stack.pop()  # Pop from stack for processing
        
        if isinstance(current_item, dict):
            # If it's a dictionary, loop through the key-value pairs
            st.subheader(current_name)  # Display the category name (subheader)
            selected_category = current_name  # Capture the selected category
            for sub_key, sub_value in current_item.items():
                if isinstance(sub_value, dict):
                    # If the value is another dictionary, add to stack
                    stack.append((f"{sub_key} (nested dictionary)", sub_value))
                elif isinstance(sub_value, list):
                    # If the value is a list, process it directly
                    st.subheader(f"{sub_key} (list)")
                    for list_item in sub_value:
                        list_item_key = generate_unique_key(section_name, sub_key, list_item)  # Ensure unique key for list items
                        checkbox_label = str(list_item)
                        
                        # Track checkbox state when in results section
                        if section_name == "results":
                            # Initialize checkbox state if not present
                            if list_item_key not in st.session_state.results_checkboxes_state:
                                st.session_state.results_checkboxes_state[list_item_key] = False
                                
                            # Get previous state and check if checkbox is checked
                            prev_state = st.session_state.results_checkboxes_state[list_item_key]
                            checked = st.checkbox(checkbox_label, key=list_item_key, value=prev_state)
                            
                            # Update state
                            st.session_state.results_checkboxes_state[list_item_key] = checked
                            
                            # Handle check/uncheck actions
                            if checked and checkbox_label not in st.session_state.selected_results_bullets:
                                # Add to selected bullets if newly checked
                                st.session_state.selected_results_bullets.append(checkbox_label)
                                selected_bullet = checkbox_label
                                show_button = True
                            elif not checked and checkbox_label in st.session_state.selected_results_bullets:
                                # Remove from selected bullets if unchecked
                                st.session_state.selected_results_bullets.remove(checkbox_label)
                        else:
                            # Normal checkbox behavior for other sections
                            if st.checkbox(checkbox_label, key=list_item_key):
                                selected_bullet = checkbox_label
                                show_button = True
                else:
                    # Otherwise, display the key and value as a checkbox
                    sub_key_value_key = generate_unique_key(section_name, sub_key, sub_value)  # Ensure unique key for key-value pairs
                    checkbox_label = f"{sub_key}: {sub_value}"
                    
                    # Track checkbox state when in results section
                    if section_name == "results":
                        # Initialize checkbox state if not present
                        if sub_key_value_key not in st.session_state.results_checkboxes_state:
                            st.session_state.results_checkboxes_state[sub_key_value_key] = False
                            
                        # Get previous state and check if checkbox is checked
                        prev_state = st.session_state.results_checkboxes_state[sub_key_value_key]
                        checked = st.checkbox(checkbox_label, key=sub_key_value_key, value=prev_state)
                        
                        # Update state
                        st.session_state.results_checkboxes_state[sub_key_value_key] = checked
                        
                        # Handle check/uncheck actions
                        if checked and checkbox_label not in st.session_state.selected_results_bullets:
                            # Add to selected bullets if newly checked
                            st.session_state.selected_results_bullets.append(checkbox_label)
                            selected_bullet = checkbox_label
                            show_button = True
                        elif not checked and checkbox_label in st.session_state.selected_results_bullets:
                            # Remove from selected bullets if unchecked
                            st.session_state.selected_results_bullets.remove(checkbox_label)
                    else:
                        # Normal checkbox behavior for other sections
                        if st.checkbox(checkbox_label, key=sub_key_value_key):
                            selected_bullet = checkbox_label
                            show_button = True
                        
        elif isinstance(current_item, list):
            # If it's a list, display each item as a checkbox
            st.subheader(current_name)  # Display the category name (subheader)
            selected_category = current_name  # Capture the selected category
            for list_item in current_item:
                list_item_key = generate_unique_key(section_name, current_name, list_item)  # Ensure unique key for list items
                checkbox_label = str(list_item)
                
                # Track checkbox state when in results section
                if section_name == "results":
                    # Initialize checkbox state if not present
                    if list_item_key not in st.session_state.results_checkboxes_state:
                        st.session_state.results_checkboxes_state[list_item_key] = False
                        
                    # Get previous state and check if checkbox is checked
                    prev_state = st.session_state.results_checkboxes_state[list_item_key]
                    checked = st.checkbox(checkbox_label, key=list_item_key, value=prev_state)
                    
                    # Update state
                    st.session_state.results_checkboxes_state[list_item_key] = checked
                    
                    # Handle check/uncheck actions
                    if checked and checkbox_label not in st.session_state.selected_results_bullets:
                        # Add to selected bullets if newly checked
                        st.session_state.selected_results_bullets.append(checkbox_label)
                        selected_bullet = checkbox_label
                        show_button = True
                    elif not checked and checkbox_label in st.session_state.selected_results_bullets:
                        # Remove from selected bullets if unchecked
                        st.session_state.selected_results_bullets.remove(checkbox_label)
                else:
                    # Normal checkbox behavior for other sections
                    if st.checkbox(checkbox_label, key=list_item_key):
                        selected_bullet = checkbox_label
                        show_button = True
        
        else:
            # Base case: Directly display the name and item as a checkbox
            base_key = generate_unique_key(section_name, current_name, current_item)  # Ensure unique key for base case
            checkbox_label = f"{current_name}: {current_item}"
            
            # Track checkbox state when in results section
            if section_name == "results":
                # Initialize checkbox state if not present
                if base_key not in st.session_state.results_checkboxes_state:
                    st.session_state.results_checkboxes_state[base_key] = False
                    
                # Get previous state and check if checkbox is checked
                prev_state = st.session_state.results_checkboxes_state[base_key]
                checked = st.checkbox(checkbox_label, key=base_key, value=prev_state)
                
                # Update state
                st.session_state.results_checkboxes_state[base_key] = checked
                
                # Handle check/uncheck actions
                if checked and checkbox_label not in st.session_state.selected_results_bullets:
                    # Add to selected bullets if newly checked
                    st.session_state.selected_results_bullets.append(checkbox_label)
                    selected_bullet = checkbox_label
                    show_button = True
                elif not checked and checkbox_label in st.session_state.selected_results_bullets:
                    # Remove from selected bullets if unchecked
                    st.session_state.selected_results_bullets.remove(checkbox_label)
            else:
                # Normal checkbox behavior for other sections
                if st.checkbox(checkbox_label, key=base_key):
                    selected_bullet = checkbox_label
                    show_button = True

    # If a selection was made, show the prompt
    if selected_bullet:
        st.write("You selected:", selected_bullet)

        # Check if the selected category is 'safety' and display appropriate prompts
        is_safety_endpoint = selected_category.lower() == "safety"

        if is_safety_endpoint:
            prompt_selection = st.selectbox(
                "Select a Prompt for Safety Endpoint",
                [
                    f"Prompt 1. Please can you describe the {selected_bullet} results relating to safety and tolerability. Referring to text and tables describing any safety or tolerability, please can you draft a paragraph describing these results and summarizing the data for it. Please can you add references to any tables or figures that would be relevant to include in a paper. Please can you provide the output as bullet points. ",
                    
                    f"Prompt 2: Please can you provide  the following data for each study arm as a bulleted list, relating to safety and tolerability, if it is available:\n"
                    "1. Patient years of exposure\n"
                    "2. The number and proportion of patients reporting at least one:\n"
                    "    a. Adverse event\n"
                    "    b. Treatment-emergent adverse event\n"
                    "    c. Serious adverse event\n"
                    "    d. Adverse event resulting in study discontinuation\n"
                    "    e. Death\n"
                    "3. The number and proportion of patients reporting at least one: Severe adverse event (please note that serious adverse events are different from severe adverse events)",
                    
                    f"Prompt 3: For each study arm please can you provide details of the 10 most common treatment emergent adverse events. If an adverse event is common in any one arm please provide the numbers for that adverse event for all study arms.",
                    
                    f"Prompt 4: For each study arm please can you provide details of the serious adverse events that were reported. For each and every serious adverse event please provide the number and proportion of patients reporting it and provide a summary of the outcomes of the events.",
                    
                    f"Prompt 5: For each study arm please can you provide details of the adverse events leading to discontinuation that were reported. For each and every adverse event please provide the number and proportion of patients reporting it and provide a summary of the outcomes of the events."
                ]
            )
        else:
            prompt_selection = st.selectbox(
                "Select a Prompt",
                [
                    f"Prompt 1: Please can you describe the results for the endpoint of {selected_bullet}. Refer to text and tables describing all analyses, please can you draft a paragraph describing this endpoint and summarizing the outcomes for it. Please can you add references to any tables or figures that would be relevant to include in a paper. Please can you provide the output as bullet points",

                    f"Prompt 2: Please can you describe the results for any subgroup analyses of the endpoint of {selected_bullet}. Refer to text and tables describing all analyses, please can you draft a paragraph describing this endpoint and summarizing the outcomes for it. Please can you add references to any tables or figures that would be relevant to include in a paper. Please can you provide the output as bullet points"
                ]
            )

        st.write("Selected Prompt:")
        st.markdown(prompt_selection)

        # Set user_query as the selected prompt
        st.session_state['user_query'] = prompt_selection  # Save the selected prompt as user_query

        # Return the show_button flag to control the button visibility
        return show_button
    return False


# display_name = "Results"






















# Reusable function to handle each section
def handle_section(section_name, display_name):
    st.subheader(display_name)

    if section_name == "results":
        generate_button = st.button(f"Generate {display_name} with predefined prompts", key=f"generate_{section_name}")
        if generate_button:
            if st.session_state.assistant_id and st.session_state.vector_id:
                try:
                    # Clear previous data for the section
                    st.session_state[section_name] = ""
                    st.session_state[f"{section_name}_citations"] = []
                    
                    # Prepare the payload
                    payload = {
                        'assistant_id': st.session_state.assistant_id,
                        'vector_id': st.session_state.vector_id
                    }

                    # Send the request to the backend
                    response = requests.post(f"{API_BASE_URL}/{section_name}/generate_results_of_checkbox_prompts", json=payload)

                    if response.status_code == 200:
                        result = response.json()
                        st.session_state[section_name] = result.get(section_name, "")
                        st.session_state[f"{section_name}_citations"] = result.get("citations", [])
                        st.session_state[f"{section_name}_thread_id"] = result.get("thread_id", None)
                        st.session_state[f"{section_name}_prompt"] = result.get(f"{section_name}_prompt", "")

                        st.success(f"{display_name} generated successfully!")
                    else:
                        error_message = response.json().get("error", f"Failed to generate {display_name.lower()}.")
                        st.error(error_message)
                except Exception as e:
                    st.error(f"Error: {str(e)}")
            else:
                st.error("Please upload your paper to generate this section.")

        if st.session_state[section_name]:
            # Editable text area for the section
            edited_text = st.text_area(f"{display_name}:", st.session_state[section_name], key=f"text_{section_name}")

        if st.session_state[section_name]:
            response = st.session_state[section_name]

            match = re.search(r"endpoints = ({.*})", response, re.DOTALL)

            if match:
                endpoints_str = match.group(1)
                # Convert the string representation to an actual Python dictionary
                endpoints_dict = ast.literal_eval(endpoints_str)
                response_dict = endpoints_dict
                # st.write(endpoints_dict)
            else:
                st.write("No match found.")
                return  # Exit if no endpoints found

            # Start the Streamlit app
            st.title("Endpoints")

            # Track whether the "Ask Assistant" button should be displayed
            show_button = False

            # Output the keys and their corresponding values
            for major_category, endpoints_dict in response_dict.items():
                show_button |= display_endpoints(major_category, endpoints_dict, section_name="results")

            if show_button:
                checkbox_dependent = st.checkbox("Dependent on threads", value=True)
                st.session_state["checkbox_dependent"] = checkbox_dependent

                get_checkbox_dependent_status = lambda: "ON" if st.session_state['checkbox_dependent'] else "OFF"

                # Display the conversation status
                st.write(f"Conversation: {get_checkbox_dependent_status()}")

            # Show "Ask Assistant" button only if a checkbox was selected
            if show_button and st.button("Run for selected prompts for checkbox"):
                
                # Store the current checkbox state in a temporary variable to restore later
                temp_checkbox_state = st.session_state.results_checkboxes_state.copy()
                temp_selected_bullets = st.session_state.selected_results_bullets.copy()
                
                checkbox_user_query = st.session_state.get('user_query', '')
                
                if checkbox_user_query:
                    try:
                        # Clear previous response and citations from the session state
                        st.session_state["checkbox_response"] = ""
                        st.session_state["checkbox_citations"] = []

                        # Send metadata and the user query to the backend
                        payload = {
                            "question": checkbox_user_query,
                            "file_name": st.session_state.file_name,
                            "assistant_id": st.session_state.assistant_id,
                            "vector_id": st.session_state.vector_id,
                            "current_thread_id": st.session_state.current_checkbox_thread_id or None,
                            "dependent": st.session_state["checkbox_dependent"], 
                        }
                        response = requests.post(f"{API_BASE_URL}/query", json=payload)
                        if response.status_code == 200:
                            result = response.json()
                            assistant_response = result.get("response", "")
                            citations = result.get("citations", [])
                            thread_id = result.get("thread_id", None)

                            st.session_state.current_checkbox_thread_id = thread_id  # Update current thread ID
                            st.session_state["checkbox_response"] = assistant_response
                            st.session_state["checkbox_citations"] = citations
                            
                            # Restore checkbox state after getting the response
                            st.session_state.results_checkboxes_state = temp_checkbox_state
                            st.session_state.selected_results_bullets = temp_selected_bullets

                            st.success("Assistant responded to your query!")
                        else:
                            # Restore checkbox state on error
                            st.session_state.results_checkboxes_state = temp_checkbox_state
                            st.session_state.selected_results_bullets = temp_selected_bullets
                            st.error(response.json().get("error", "Please upload the file to start your query"))
                    except Exception as e:
                        # Restore checkbox state on exception
                        st.session_state.results_checkboxes_state = temp_checkbox_state
                        st.session_state.selected_results_bullets = temp_selected_bullets
                        st.error(f"Error: {str(e)}")
                else:
                    # Restore checkbox state if no query
                    st.session_state.results_checkboxes_state = temp_checkbox_state
                    st.session_state.selected_results_bullets = temp_selected_bullets
                    st.error("Please enter a query before asking.")

            # Display editable text area for the query response
            if st.session_state["checkbox_response"]:
            
                st.header("üí¨ Response")
                response_text = st.text_area("Response:", st.session_state["checkbox_response"], height=200, key="checkbox_response_text")
                citations = st.session_state["checkbox_citations"]

                if st.session_state.current_checkbox_thread_id:
                    st.markdown(f"**Thread ID:** {st.session_state.current_checkbox_thread_id}")

                if "user_query" in st.session_state and st.session_state["checkbox_response"]:

                    # Save Response Button
                    if st.button("Save Response", key="save_checkbox_response_button"): 
                        payload = {
                            'file_name': st.session_state.file_name,
                            'user_query': st.session_state.user_query,
                            'assistant_response': st.session_state.checkbox_response,
                            'citations': st.session_state.checkbox_citations,
                            'thread_id': st.session_state.current_checkbox_thread_id
                        }
                        try:
                            save_response = requests.post(f"{API_BASE_URL}/save_checkbox_response", json=payload)
                            if save_response.status_code == 200:
                                st.success("Response saved successfully!")
                            else:
                                st.error("Error saving response.")
                        except Exception as e:
                            st.error(f"An error occurred: {e}")

    elif section_name == "methods":
        # If there are selected results bullets, display them in the methods section
        if st.session_state.selected_results_bullets and len(st.session_state.selected_results_bullets) > 0:
            st.subheader("Selected Results Bullets")
            
            # Add a button to clear all selected results
            if st.button("Clear All Selected Results", key="clear_all_results"):
                st.session_state.selected_results_bullets = []
                st.session_state.selected_methods_items = []
                st.session_state.results_checkboxes_state = {}
                st.success("All selected results have been cleared.")
                st.rerun()  # Corrected from experimental_rerun to rerun
            
            # Display each selected result with a checkbox and a remove button
            selected_bullets_to_remove = []
            for idx, result_bullet in enumerate(st.session_state.selected_results_bullets):
                col1, col2 = st.columns([4, 1])
                
                with col1:
                    bullet_key = generate_unique_key("methods_selection", result_bullet)
                    # Check if this item is already in selected methods items
                    is_selected = result_bullet in st.session_state.selected_methods_items
                    if st.checkbox(result_bullet, key=bullet_key, value=is_selected):
                        if result_bullet not in st.session_state.selected_methods_items:
                            st.session_state.selected_methods_items.append(result_bullet)
                    else:
                        if result_bullet in st.session_state.selected_methods_items:
                            st.session_state.selected_methods_items.remove(result_bullet)
                
                with col2:
                    # Add a remove button for each bullet
                    if st.button("Remove", key=f"remove_bullet_{idx}"):
                        selected_bullets_to_remove.append(result_bullet)
            
            # Process removals after the loop to avoid modifying list during iteration
            if selected_bullets_to_remove:
                for bullet in selected_bullets_to_remove:
                    if bullet in st.session_state.selected_results_bullets:
                        st.session_state.selected_results_bullets.remove(bullet)
                    if bullet in st.session_state.selected_methods_items:
                        st.session_state.selected_methods_items.remove(bullet)
                st.success(f"Removed {len(selected_bullets_to_remove)} item(s)")
                st.rerun()  # Corrected from experimental_rerun to rerun
            
            # If methods items are selected, show dropdown with appropriate prompts
            if st.session_state.selected_methods_items and len(st.session_state.selected_methods_items) > 0:
                st.subheader("Selected Methods Items")
                
                # Display the selected methods items
                for item in st.session_state.selected_methods_items:
                    st.write(f"- {item}")
                
                # Create a comma-separated list of selected items for the prompt
                selected_items_text = ", ".join(st.session_state.selected_methods_items)
                
                # Show dropdown with prompts for methods section
                methods_prompt = st.selectbox(
                    "Select a Prompt for Methods Analysis",
                    [
                        f"Prompt 1: Please describe the methods used to analyze {selected_items_text}. Include details on study design, statistical approaches, and any specific techniques employed.",
                        
                        f"Prompt 2: For the endpoints {selected_items_text}, please provide a detailed explanation of the measurement techniques, data collection methods, and analysis protocols used.",
                        
                        f"Prompt 3: Please explain the methodological considerations for analyzing {selected_items_text}, including any adjustments made for confounding variables or bias."
                    ],
                    key="methods_prompt_selection"
                )
                
                st.write("Selected Methods Prompt:")
                st.markdown(methods_prompt)
                
                # Set user_query for methods as the selected prompt
                st.session_state['methods_query'] = methods_prompt
                
                # Add a button to run the methods query
                if st.button("Run Methods Analysis", key="run_methods_analysis"):
                    methods_query = st.session_state.get('methods_query', '')
                    
                    if methods_query:
                        try:
                            # Clear previous response for methods
                            st.session_state["methods_response"] = ""
                            st.session_state["methods_citations"] = []
                            
                            # Send request to backend
                            payload = {
                                "question": methods_query,
                                "file_name": st.session_state.file_name,
                                "assistant_id": st.session_state.assistant_id,
                                "vector_id": st.session_state.vector_id,
                                "current_thread_id": st.session_state.get("methods_thread_id") or None,
                                "dependent": True,
                            }
                            
                            response = requests.post(f"{API_BASE_URL}/query", json=payload)
                            if response.status_code == 200:
                                result = response.json()
                                methods_response = result.get("response", "")
                                citations = result.get("citations", [])
                                thread_id = result.get("thread_id", None)
                                
                                st.session_state["methods_thread_id"] = thread_id
                                st.session_state["methods_response"] = methods_response
                                st.session_state["methods_citations"] = citations
                                
                                st.success("Methods analysis completed!")
                            else:
                                st.error(response.json().get("error", "Failed to process methods query"))
                        except Exception as e:
                            st.error(f"Error: {str(e)}")
                    else:
                        st.error("Please select a methods prompt before running analysis.")
                
                # Display methods response if available
                if "methods_response" in st.session_state and st.session_state["methods_response"]:
                    st.header("üí¨ Methods Response")
                    methods_text = st.text_area("Response:", st.session_state["methods_response"], height=200, key="methods_response_text")
                    
                    if st.session_state.get("methods_thread_id"):
                        st.markdown(f"**Thread ID:** {st.session_state['methods_thread_id']}")
                    
                    # Save Methods Response Button
                    if st.button("Save Methods Response", key="save_methods_response_button"):
                        payload = {
                            'file_name': st.session_state.file_name,
                            'user_query': st.session_state.get('methods_query', ''),
                            'assistant_response': methods_text,
                            'citations': st.session_state.get("methods_citations", []),
                            'thread_id': st.session_state.get("methods_thread_id")
                        }
                        try:
                            save_response = requests.post(f"{API_BASE_URL}/save_response", json=payload)
                            if save_response.status_code == 200:
                                st.success("Methods response saved successfully!")
                            else:
                                st.error("Error saving methods response.")
                        except Exception as e:
                            st.error(f"An error occurred: {e}")

    # Chat Functionality
    with st.expander(f"Initialise New chat for {display_name}"):
        user_message = st.text_input(f"Enter your message for the {display_name}:", key=f"user_message_outside_{section_name}")

        if st.button("Run", key=f"send_message_outside_{section_name}"):
            if user_message and st.session_state.assistant_id and st.session_state.vector_id:
                try:
                    # Prepare the payload
                    payload = {
                        'assistant_id': st.session_state.assistant_id,
                        'vector_id': st.session_state.vector_id,
                        'thread_id': st.session_state[f'initialise_new_chat_for_outside_{section_name}_thread_id'], 
                        'message': user_message
                    }

                    # Send the request to the backend
                    response = requests.post(f"{API_BASE_URL}/{section_name}/chat_{section_name}", json=payload)

                    if response.status_code == 200:
                        result = response.json()
                        st.session_state[f"outside_{section_name}_chat"] = result.get("response", "")
                        st.session_state[f"outside_{section_name}_chat_citations"] = result.get("citations", [])
                        st.session_state[f"initialise_new_chat_for_outside_{section_name}_thread_id"] = result.get("thread_id", None)

                        st.success("Message sent successfully!")
                    else:
                        error_message = response.json().get("error", "Failed to process the chat.")
                        st.error(error_message)
                except Exception as e:
                    st.error(f"An error occurred: {e}")
            else:
                st.error("Please upload your paper to send a message.")

        if st.session_state[f"outside_{section_name}_chat"]:
            chat_text = st.text_area(f"{display_name} Chat:", st.session_state[f"outside_{section_name}_chat"], key=f"chat_text_outside_{section_name}")
            chat_citations = st.session_state[f"{section_name}_chat_citations"]
            st.write(f"thread ID {st.session_state[f'initialise_new_chat_for_outside_{section_name}_thread_id']}")

            # Save Chat Button
            if st.button(f"Save {display_name} Chat", key=f"save_chat_outside_{section_name}"):
                payload = {
                    'file_name': st.session_state.file_name,
                    'user_query': user_message,
                    'assistant_response': chat_text,
                    'citations': chat_citations,
                    'thread_id': st.session_state[f"initialise_new_chat_for_outside_{section_name}_thread_id"]
                }
                try:
                    save_response = requests.post(f"{API_BASE_URL}/{section_name}/save_outside_{section_name}_chat_response", json=payload)
                    if save_response.status_code == 200:
                        st.success(f"{display_name} Chat saved successfully!")
                    else:
                        st.error(f"Error saving {display_name.lower()} chat.")
                except Exception as e:
                    st.error(f"An error occurred: {e}")





# Tabs for Document Sections
st.header("üìÑ Document Sections")
tabs = st.tabs(["**Results**", "**Methods**", "**Introduction**", "**Discussion**", "**Conclusion**"])

sections = ["results", "methods", "introduction", "discussion", "conclusion"]
display_names = ["Results", "Methods", "Introduction", "Discussion", "Conclusion"]

for tab, section, display_name in zip(tabs, sections, display_names):
    with tab:
        handle_section(section, display_name)













